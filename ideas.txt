
# TODO:
2. Could the binary variable $y$ be removed?


# experiments
x_00, x01, x02, x03
x_10, x11, x12, x13
x_20, x21, x22, x23
x_30, x31, x32, x33
x_40, x41, x42, x43
x_50, x51, x52, x53
x_60, x61, x62, x63
x_70, x71, x72, x73

solution is (1,2,3,4)
guess is (5,2,7,1)
then key pegs:
white, none, none, red

constraints:
white: 1-x0g + 1-x1g + 1-x2g + 1-x3g <= num white

#notes
this constraint will count the make sure that 
colors not in the solution are removed from the guess
and it will also remove the need of the variable y
constraint = pulp.lpSum(1 - x[b][c] for b in ball_ids for c in guess) == len(ball_ids) * hint.count(PegColors.NONE), ""



this solver solves it without y. but cant manage duplicates


    def solve2(self, quiet=True, write_lp_file=False) -> Tuple[List[Colors], int]:

        iterations = 0

        guess = self.create_guess()

        hint = self.mastermind.get_hint(guess)

        if all(c == PegColors.RED for c in hint):
            return guess, iterations

        ball_ids = range(self.mastermind.code_length)
        color_ids = list(Colors)

        prob = pulp.LpProblem("mastermind_problem", pulp.LpMinimize)

        # the variable x[b][c] is 1 iff ball b has color c
        x = pulp.LpVariable.dicts(name = "x",
                              indices = (ball_ids, color_ids),
                              cat = "Binary")

        # for some reason we need to set this to something. not sure why?
        prob += x[0][Colors.RED], "Objective_Function" 

        # create some general constraints:
        # 1. each ball position has exactly one color
        for b in ball_ids:
            constraint = pulp.lpSum(x[b][c] for c in color_ids) == 1, ""
            prob += constraint

        # 2. if duplicates are not allowed, a color can only be chosen once
        if not self.mastermind.allow_duplicates:

            for c in color_ids:
               constraint = pulp.lpSum(x[b][c] for b in ball_ids) <= 1, ""
               prob += constraint

        while any(h != PegColors.RED for h in hint):
            iterations += 1

            if iterations > 10:
                raise Exception(f"Too many iterations. solution: {self.mastermind.solution}")

            # color red represents the number of correct ball colors in the correct position
            constraint = pulp.lpSum(x[b][c] for b,c in enumerate(guess)) == hint.count(PegColors.RED) , ""
            prob += constraint

            # color white represents the number of correct ball colors in the wrong position
            constraint = pulp.lpSum(x[b][c] for b in ball_ids for c in guess) == hint.count(PegColors.WHITE) + hint.count(PegColors.RED), ""
            #constraint = pulp.lpSum(x[b][c] for b in ball_ids for c in guess if (b,c) not in enumerate(guess)) == hint.count(PegColors.WHITE), ""
            prob += constraint

            # color none represents the number of colors that are not in the solution
            #constraint = pulp.lpSum(1 - x[b][c] for b in ball_ids for c in guess) == hint.count(PegColors.NONE), ""

            if write_lp_file:
                prob.writeLP(f"tmp/model_{iterations}.lp")

            # solve the problem
            if quiet:
                prob.solve(solver=pulp.PULP_CBC_CMD(timeLimit=60, msg=False))
            else:
                prob.solve()

            status = pulp.LpStatus[prob.status]

            if status != "Optimal":
                raise Exception(f"No optimal solution found. Status: {status}, iterations: {iterations}, guess: {guess}, hint: {hint}")

            new_guess = self.mastermind.code_length*[None]
            for b in ball_ids:
                for c in color_ids:
                    if x[b][c].varValue == 1:
                        new_guess[b] = c

            guess = new_guess
            hint = self.mastermind.get_hint(guess)
        
        return guess, iterations